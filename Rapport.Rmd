---
title: "Data Science"
author: "Merlin Gérard, Estelle Strade, Hugo Phipps"
date: "11/8/2020"
output: 
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE, message=FALSE )

# Load your packages here
library(data.table)
library(ggplot2)
library(PerformanceAnalytics)
library(gridExtra)
library(gstat)
theme_set(theme_classic())
library(car)
library(latticeExtra)
library(AID) 
```

## Introduction

```{r}
#Retirer le '#' devant le fread correspondant à ton chemin en local

#data3 <- fread("/Users/merlingerard/Desktop/projet_stat/Projet-STAT/groupe3.csv")
data3 <- fread("C:/Users/hugop/Desktop/projet_stat/Projet-STAT/groupe3.csv")
#data3 <- fread("/Users/estellestrade/Desktop/projet_stat/Projet-STAT/groupe3.csv")

head(data3)
summary(data3)
```

### Récap nom de variable

* data3 = base de données brute de base

* Cdbx, Pbbx, Crbx = Transformation boxcox des différentes distribution de concentration de métaux pour en faire une distribution normale (pas forrcément nécessaire pour le chrome) --> ajouté dans nouvelle colonne à data3

* data3.XX = retire toutes lignes comprenant un NA pour le métal XX

* data3.NAclean = base de données data3 sans aucun NA

* clean.XX = base de données data3 sans NA ni valeurs aberrantes pour le métal XX (boxcox)

* clean.data3 = base de données data3 sans NA ni valeurs abberrantes pour tous les métaux (boxcox)

### Graphes 

#### Cadmium

```{r}
#Cadmium
map_Cd <- ggplot(data3) + geom_point(aes(x=X, y=Y, color=Cd), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cadmium measures map") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Cadmium [mg/kg]", low='yellow', high='darkblue')
map_Cd
```

#### Plomb

```{r}
#Plomb
map_Pb <- ggplot(data3) + geom_point(aes(x=X, y=Y, color=Pb), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Lead measures map") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Lead [mg/kg]", low='lightblue', high='darkblue')
map_Pb
```

#### Chrome

```{r}
#Chrome
map_Cr <- ggplot(data3) + geom_point(aes(x=X, y=Y, color=Cr), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Chrome measures map") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Chrome [mg/kg]", low='yellow', high='darkgreen')
map_Cr
```


### Outliers removal

```{r}
#Transformation boxcox Cadmium

Cdbx <- boxcoxnc(na.omit(data3$Cd), verbose = FALSE) # Find best alpha 
data3[!is.na(Cd),Cdbx := Cdbx$tf.data] # Create column with transformed data
alpha.Cd <- Cdbx$lambda.hat

#Transformation boxcox Plomb

Pbbx <- boxcoxnc(na.omit(data3$Pb), verbose = FALSE) # Find best alpha 
data3[!is.na(Pb),Pbbx := Pbbx$tf.data] # Create column with transformed data
alpha.Pb <- Pbbx$lambda.hat

#Transformation boxcox Chrome --> #On en fait pas car distribution déjà normal

Crbx <- boxcoxnc(na.omit(data3$Cr), verbose = FALSE) # Find best alpha 
data3[!is.na(Cr),Crbx := Crbx$tf.data] # Create column with transformed data
alpha.Cr <- Crbx$lambda.hat

#je retire les NA pour les différentes concentrations de métaux

data3.Cd <- data3[rowSums(is.na(data3[,5]),) == 0, ] #retire tous les NA du cadmium (version boxcox ou non)
data3.Pb <- data3[rowSums(is.na(data3[,6]),) == 0, ] #retire tous les NA du plomb (version boxcox ou non)
data3.Cr <- data3[rowSums(is.na(data3[,7]),) == 0, ] #retire tous les NA du chrome (version boxcox ou non)

data3.NAclean <- data3[rowSums(is.na(data3),) == 0, ] #retire toutes les lignes avec au moins 1 NA


#Pour le chrome
sd.Cr <- sd(data3.Cr$Crbx)
mean.Cr <- mean(data3.Cr$Crbx)
sd.Cr
mean.Cr

#Pour le cadmium
sd.Cd <- sd(data3.Cd$Cdbx)
mean.Cd <- mean(data3.Cd$Cdbx)

#Pour le plomb
sd.Pb <- sd(data3.Pb$Pbbx)
mean.Pb <- mean(data3.Pb$Pbbx)

#Maintenant je vais retirer les outliers (= valeurs aberrantes) du jeu de données en ne conservant que les données avec une valeur situé entre + et - 3 fois l'écart-type (= standard deviation) de la moyenne (= mean) pour CHAQUE concentration indépendamment, pour ne perdre aucune info sur les cartes individuelles des métaux

clean.Cd <- data3.Cd[data3.Cd$Cdbx %between% c(mean.Cd-3*sd.Cd,mean.Cd+3*sd.Cd),]

clean.Pb <- data3.Pb[data3.Pb$Pbbx %between% c(mean.Pb-3*sd.Pb,mean.Pb+3*sd.Pb),]

clean.Cr <- data3.Cr[data3.Cr$Crbx %between% c(mean.Cr-3*sd.Cr,mean.Cr+3*sd.Cr),]

#la je retire au fur et à mesure les valeurs aberrantes des différents métaux pour obtenir un data3 final qui est clean, sans NA ni valeurs aberrantes pour l'ensemble des métaux

#sert à comparer les concentrations là où il existe les 3 valeurs (et aucune aberrantes)

clean.data3 <- data3.NAclean[data3.NAclean$Crbx %between% c(mean.Cr-3*sd.Cr,mean.Cr+3*sd.Cr),] #commence avec data3.NAclean pour retirer toutes les lignes avec au moins 1 NA (puisuq'on veut comparer toutes les concentrations entre elles: pas d'intérêt de garder les points avec une ou deux concentrations manquantes)
clean.data3 <- clean.data3[clean.data3$Pbbx %between% c(mean.Pb-3*sd.Pb,mean.Pb+3*sd.Pb),]
clean.data3 <- clean.data3[clean.data3$Cdbx %between% c(mean.Cd-3*sd.Cd,mean.Cd+3*sd.Cd),] #data3 sans NA ni valeurs aberrantes final.


```

### Graphes sans outliers

#### Cadmium sans outliers

```{r}
#Cadmium
map_Cd <- ggplot(data3.Cd) + geom_point(aes(x=X, y=Y, color=Cd), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cadmium measures map (no NA)") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Cadmium [mg/kg]", low='yellow', high='darkblue')
map_Cd
```

#### Plomb sans outliers

```{r}
#Plomb
map_Pb <- ggplot(data3.Pb) + geom_point(aes(x=X, y=Y, color=Pb), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Lead measures map (no NA)") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Lead [mg/kg]", low='lightblue', high='darkblue')
map_Pb
```

#### Chrome sans outliers

```{r}
#Chrome
map_Cr <- ggplot(data3.Cr) + geom_point(aes(x=X, y=Y, color=Cr), size=1) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Chrome measures map (no NA)") +
                 theme(plot.title=element_text(hjust=0.5)) + # center title
                 scale_color_gradient(name="Chrome [mg/kg]", low='yellow', high='darkgreen')
map_Cr
```


### Distribution des variables

```{r}
#Cadmium
ggplot(clean.Cd, aes(x = Cdbx)) +
  geom_histogram(aes(y = ..density..,  # display density function (and not count)
                     fill = "Density histogram" ),
                 bins = 15, # number of bins
                 color = "white") + 
  geom_density(col = "lightsteelblue3", 
               aes(fill = "Fitted pdf"), 
               alpha = 0.2) +  
  xlab("Cd content [mg/kg]") + 
  ylab("f(x)") + 
  ggtitle("Density histogram of the Cadmium content") +
  stat_function(fun=dnorm, # display a normal distribution
                args=list(mean = mean(clean.Cd$Cdbx), sd = sd(clean.Cd$Cdbx)), 
                aes(color="Normal pdf"),
                size= 1) + # width of the line
  scale_fill_manual("", values = c("Density histogram"="lightsteelblue2",
                                    "Fitted pdf"=alpha("lightsteelblue3",.2))) +
  scale_color_manual("", values="red")

ggplot(clean.Cd, aes(x = Cdbx)) + 
  stat_ecdf(geom = "step", aes(color = "Estimated cdf")) +  # Estimated Cumulative Density Function
  xlab("Cd content [mg/kg]") + 
  ylab("F(x)") + 
  ggtitle("Estimated vs normal cdf of the Cadmium content") +
  stat_function(fun = pnorm, # display a normal cumulative distribution
                args = list(mean = mean(clean.Cd$Cdbx), sd = sd(clean.Cd$Cdbx)), 
                aes(color = 'Normal cdf'),
                size= 1) +
  scale_color_manual("", values = c("Estimated cdf" = "black",
                                    "Normal cdf" = "red")) 

#Pour voir si ça suit le normal
qqPlot(clean.Cd$Cdbx)
```

```{r}
#Plomb
ggplot(clean.Pb, aes(x = Pbbx)) + 
  geom_histogram(aes(y = ..density..,  # display density function (and not count)
                     fill = "Density histogram" ),
                 bins = 15, # number of bins
                 color = "white") + 
  geom_density(col = "lightsteelblue3", 
               aes(fill = "Fitted pdf"), 
               alpha = 0.2) +  
  xlab("Pb content [mg/kg]") + 
  ylab("f(x)") + 
  ggtitle("Density histogram of the Lead content") +
  stat_function(fun=dnorm, # display a normal distribution
                args=list(mean = mean(clean.Pb$Pbbx), sd = sd(clean.Pb$Pbbx)), 
                aes(color="Normal pdf"),
                size= 1) + # width of the line
  scale_fill_manual("", values = c("Density histogram"="lightsteelblue2",
                                    "Fitted pdf"=alpha("lightsteelblue3",.2))) +
  scale_color_manual("", values="red")

ggplot(clean.Pb, aes(x = Pbbx)) + 
  stat_ecdf(geom = "step", aes(color = "Estimated cdf")) +  # Estimated Cumulative Density Function
  xlab("Pb content [mg/kg]") + 
  ylab("F(x)") + 
  ggtitle("Estimated vs normal cdf of the Lead content") +
  stat_function(fun = pnorm, # display a normal cumulative distribution
                args = list(mean = mean(clean.Pb$Pbbx), sd = sd(clean.Pb$Pbbx)), 
                aes(color = 'Normal cdf'),
                size= 1) +
  scale_color_manual("", values = c("Estimated cdf" = "black",
                                    "Normal cdf" = "red")) 
#Pour voir si ça suit le normal
qqPlot(clean.Pb$Pbbx)
```

```{r}
#Chrome 
ggplot(clean.Cr, aes(x = Crbx)) +
  geom_histogram(aes(y = ..density..,  # display density function (and not count)
                     fill = "Density histogram" ),
                 bins = 15, # number of bins
                 color = "white") + 
  geom_density(col = "lightsteelblue3", 
               aes(fill = "Fitted pdf"), 
               alpha = 0.2) +  
  xlab("Cr content [mg/kg]") + 
  ylab("f(x)") + 
  ggtitle("Density histogram of the Chrome content") +
  stat_function(fun=dnorm, # display a normal distribution
                args=list(mean = mean(clean.Cr$Crbx), sd = sd(clean.Cr$Crbx)), 
                aes(color="Normal pdf"),
                size= 1) + # width of the line
  scale_fill_manual("", values = c("Density histogram"="lightsteelblue2",
                                    "Fitted pdf"=alpha("lightsteelblue3",.2))) +
  scale_color_manual("", values="red")

ggplot(clean.Cr, aes(x = Crbx)) + 
  stat_ecdf(geom = "step", aes(color = "Estimated cdf")) +  # Estimated Cumulative Density Function
  xlab("Cr content [mg/kg]") + 
  ylab("F(x)") + 
  ggtitle("Estimated vs normal cdf of the Chrome content") +
  stat_function(fun = pnorm, # display a normal cumulative distribution
                args = list(mean = mean(clean.Cr$Crbx), sd = sd(clean.Cr$Crbx)), 
                aes(color = 'Normal cdf'),
                size= 1) +
  scale_color_manual("", values = c("Estimated cdf" = "black",
                                    "Normal cdf" = "red")) 

#Pour voir si ça suit le normal
qqPlot(clean.Cr$Crbx)
```


### Corrélations

```{r}
#scatterplots
h1 <- ggplot(clean.data3) + geom_histogram(aes(x=Cd), bins=10, color='white')
h2 <- ggplot(clean.data3) + geom_histogram(aes(x=Pb), bins=10, color='white')
h3 <- ggplot(clean.data3) + geom_histogram(aes(x=Cr), bins=10, color='white')
p1 <- ggplot(clean.data3) + geom_point(aes(x=Cd, y=Pb))
p2 <- ggplot(clean.data3) + geom_point(aes(x=Cd, y=Cr))
p3 <- ggplot(clean.data3) + geom_point(aes(x=Pb, y=Cr))
gNA <- ggplot(clean.data3) + theme_void() # This is just an empty plot.

grid.arrange(h1,p1,p2,gNA, h2,p3,gNA,gNA,h3,
             ncol=3, top="Scatterplots")

#Correlation chart
chart.Correlation(clean.data3[,.(Cd,Pb,Cr)])
```
#Semi-variogram pour Cd
```{r Cd variogram values}
#Code
Cd.gstat <- gstat(formula = Cd~1, data = clean.data3, locations = ~X+Y)
Cd.vario <- variogram(Cd.gstat, cutoff =800000 , width = 798)
vg.model <- vgm(psill = 2, model ='Exp' , range= 600)
fit.vg.model <- fit.variogram(Cd.vario, model=vg.model)
plot(Cd.vario, model=fit.vg.model, main="Variogram of Cd", pch=16, col="black")
#Variance of rain
trellis.focus("panel",1,1)
llines(x=c(196300, 279509.0), y=c(93704, 163250.0), col="red", lwd=1, lty=2)
trellis.unfocus()
```

#Semi-variogram pour Cr
```{r Cr variogram values}
#Code
Cr.gstat <- gstat(formula = Cr~1, data = clean.data3, locations = ~X+Y)
Cr.vario <- variogram(Cr.gstat, cutoff =10000 , width = 1000)
vg.model <- vgm(psill = 100, model ='Exp' , range= 1200)
fit.vg.model <- fit.variogram(Cr.vario, model=vg.model)
plot(Cr.vario, model=fit.vg.model, main="Variogram of Cr", pch=16, col="black")
#Variance of rain
trellis.focus("panel",1,1)
llines(x=c(196300, 279509.0), y=c(93704, 163250.0), col="red", lwd=1, lty=2)
trellis.unfocus()
```

#Semi-variogram pour Pb
```{r Pb variogram values}
#Code
Pb.gstat <- gstat(formula = Pb~1, data = clean.data3, locations = ~X+Y)
Pb.vario <- variogram(Cd.gstat, cutoff =300000 , width = 798)
vg.model <- vgm(psill = 2, model ='Exp' , range= 600)
fit.vg.model <- fit.variogram(Pb.vario, model=vg.model)
plot(Cd.vario, model=fit.vg.model, main="Variogram of Pb", pch=16, col="black")
#Variance of rain
trellis.focus("panel",1,1)
llines(x=c(196300, 279509.0), y=c(93704, 163250.0), col="red", lwd=1, lty=2)
trellis.unfocus()
```

#3Dplot of Cd 
```{r Cd derive}
Cd.lm <- lm(Cd ~X+Y, data = clean.data3)

test <- scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$Cd, 
          xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Cd')

rglwidget(width = 800000, height = 300)

#Compute the vector of residuals by substracting the trend values to the initial values of Cd
Cd.derive <- predict(Cd.lm, clean.data3)
clean.data3[, clean.Cd := Cd - Cd.derive]
scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$clean.Cd, 
           xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Cd')
rglwidget(width = 800000, height = 300)

# remove outliers: we only keep data within 3sd from the mean
res.Sd <- sd(clean.data3$clean.Cd)
res.Mean <- mean(clean.data3$clean.Cd)
clean.clean.data3 <- clean.data3[clean.Cd %between% 
c(res.Mean-3*res.Sd,res.Mean+3*res.Sd),]

# Map residuals
ggplot(clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Cd), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cd residuals map") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Cd [mm]", low='yellow', high='darkblue')

# Map clean residuals
ggplot(clean.clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Cd), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cd residuals map (no outliers)") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Cd [mm]", low='yellow', high='darkblue')

```

#3Dplot of Cr
```{r Cr derive}
Cr.lm <- lm(Cr ~X+Y, data = clean.data3)

test <- scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$Cr, 
          xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Cr')

rglwidget(width = 800000, height = 300)

#Compute the vector of residuals by substracting the trend values to the initial values of Cr
Cr.derive <- predict(Cr.lm, clean.data3)
clean.data3[, clean.Cr := Cr - Cr.derive]
scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$clean.Cr, 
           xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Cr')
rglwidget(width = 800000, height = 300)

# remove outliers: we only keep data within 3sd from the mean
res.Sd <- sd(clean.data3$clean.Cr)
res.Mean <- mean(clean.data3$clean.Cr)
clean.clean.data3 <- clean.data3[clean.Cr %between% 
c(res.Mean-3*res.Sd,res.Mean+3*res.Sd),]

# Map residuals
ggplot(clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Cr), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cr residuals map") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Cr [mm]", low='yellow', high='darkblue')

# Map clean residuals
ggplot(clean.clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Cr), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Cr residuals map (no outliers)") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Cr [mm]", low='yellow', high='darkblue')

```

#3Dplot of Pb
```{r Cd derive}
Pb.lm <- lm(Pb ~X+Y, data = clean.data3)

test <- scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$Pb, 
          xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Pb')

rglwidget(width = 800000, height = 300)

#Compute the vector of residuals by substracting the trend values to the initial values of Pb
Pb.derive <- predict(Pb.lm, clean.data3)
clean.data3[, clean.Pb := Pb - Pb.derive]
scatter3d(x = clean.data3$X, z = clean.data3$Y, y = clean.data3$clean.Pb, 
           xlab = 'Longitude', zlab = 'Lattitude', ylab = 'Pb')
rglwidget(width = 800000, height = 300)

# remove outliers: we only keep data within 3sd from the mean
res.Sd <- sd(clean.data3$clean.Pb)
res.Mean <- mean(clean.data3$clean.Pb)
clean.clean.data3 <- clean.data3[clean.Pb %between% 
c(res.Mean-3*res.Sd,res.Mean+3*res.Sd),]

# Map residuals
ggplot(clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Pb), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Pb residuals map") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Pb [mm]", low='yellow', high='darkblue')

# Map clean residuals
ggplot(clean.clean.data3) + geom_point(aes(x=X, y=Y, color=clean.Pb), size=4) + 
                 xlab("Longitude") + ylab("Lattitude") + 
                 ggtitle("Pb residuals map (no outliers)") +
                 theme(plot.title=element_text(hjust=0.5)) + 
                 scale_color_gradient(name="Pb [mm]", low='yellow', high='darkblue')

```
